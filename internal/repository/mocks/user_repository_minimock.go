// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/merynayr/auth/internal/repository.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/merynayr/auth/internal/model"
	"google.golang.org/protobuf/types/known/emptypb"
)

// UserRepositoryMock implements mm_repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user *model.User) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, userID int64) (ep1 *emptypb.Empty, err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, userID int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserRepositoryMockDeleteUser

	funcGetUserByID          func(ctx context.Context, userID int64) (up1 *model.User, err error)
	funcGetUserByIDOrigin    string
	inspectFuncGetUserByID   func(ctx context.Context, userID int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mUserRepositoryMockGetUserByID

	funcGetUserByName          func(ctx context.Context, name string) (up1 *model.UserInfo, err error)
	funcGetUserByNameOrigin    string
	inspectFuncGetUserByName   func(ctx context.Context, name string)
	afterGetUserByNameCounter  uint64
	beforeGetUserByNameCounter uint64
	GetUserByNameMock          mUserRepositoryMockGetUserByName

	funcIsNameExist          func(ctx context.Context, name string) (b1 bool, err error)
	funcIsNameExistOrigin    string
	inspectFuncIsNameExist   func(ctx context.Context, name string)
	afterIsNameExistCounter  uint64
	beforeIsNameExistCounter uint64
	IsNameExistMock          mUserRepositoryMockIsNameExist

	funcUpdateUser          func(ctx context.Context, user *model.UserUpdate) (ep1 *emptypb.Empty, err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, user *model.UserUpdate)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserRepositoryMockUpdateUser
}

// NewUserRepositoryMock returns a mock for mm_repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserRepositoryMockCreateUserParams{}

	m.DeleteUserMock = mUserRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserRepositoryMockDeleteUserParams{}

	m.GetUserByIDMock = mUserRepositoryMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*UserRepositoryMockGetUserByIDParams{}

	m.GetUserByNameMock = mUserRepositoryMockGetUserByName{mock: m}
	m.GetUserByNameMock.callArgs = []*UserRepositoryMockGetUserByNameParams{}

	m.IsNameExistMock = mUserRepositoryMockIsNameExist{mock: m}
	m.IsNameExistMock.callArgs = []*UserRepositoryMockIsNameExistParams{}

	m.UpdateUserMock = mUserRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserRepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreateUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateUserExpectation
	expectations       []*UserRepositoryMockCreateUserExpectation

	callArgs []*UserRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockCreateUserExpectation specifies expectation struct of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockCreateUserParams
	paramPtrs          *UserRepositoryMockCreateUserParamPtrs
	expectationOrigins UserRepositoryMockCreateUserExpectationOrigins
	results            *UserRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockCreateUserParams contains parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParams struct {
	ctx  context.Context
	user *model.User
}

// UserRepositoryMockCreateUserParamPtrs contains pointers to parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **model.User
}

// UserRepositoryMockCreateUserResults contains results of the UserRepository.CreateUser
type UserRepositoryMockCreateUserResults struct {
	i1  int64
	err error
}

// UserRepositoryMockCreateUserOrigins contains origins of expectations of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRepositoryMockCreateUser) Optional() *mUserRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Expect(ctx context.Context, user *model.User) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserRepositoryMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectUserParam2(user *model.User) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Inspect(f func(ctx context.Context, user *model.User)) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserRepositoryMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserRepository.CreateUser method
func (mmCreateUser *mUserRepositoryMockCreateUser) Set(f func(ctx context.Context, user *model.User) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the UserRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRepositoryMockCreateUser) When(ctx context.Context, user *model.User) *UserRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserRepositoryMockCreateUserParams{ctx, user},
		expectationOrigins: UserRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateUserExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepository.CreateUser should be invoked
func (mmCreateUser *mUserRepositoryMockCreateUser) Times(n uint64) *mUserRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.UserRepository
func (mmCreateUser *UserRepositoryMock) CreateUser(ctx context.Context, user *model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserRepositoryMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserRepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserRepositoryMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRepositoryMockCreateUser) Calls() []*UserRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserRepositoryMockDeleteUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteUserExpectation
	expectations       []*UserRepositoryMockDeleteUserExpectation

	callArgs []*UserRepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockDeleteUserExpectation specifies expectation struct of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockDeleteUserParams
	paramPtrs          *UserRepositoryMockDeleteUserParamPtrs
	expectationOrigins UserRepositoryMockDeleteUserExpectationOrigins
	results            *UserRepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockDeleteUserParams contains parameters of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserParams struct {
	ctx    context.Context
	userID int64
}

// UserRepositoryMockDeleteUserParamPtrs contains pointers to parameters of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserRepositoryMockDeleteUserResults contains results of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserResults struct {
	ep1 *emptypb.Empty
	err error
}

// UserRepositoryMockDeleteUserOrigins contains origins of expectations of the UserRepository.DeleteUser
type UserRepositoryMockDeleteUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Optional() *mUserRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Expect(ctx context.Context, userID int64) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserRepositoryMockDeleteUserParams{ctx, userID}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectUserIDParam2 sets up expected param userID for UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) ExpectUserIDParam2(userID int64) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, userID int64)) *mUserRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserRepository.DeleteUser
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Return(ep1 *emptypb.Empty, err error) *UserRepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserRepositoryMockDeleteUserResults{ep1, err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserRepository.DeleteUser method
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Set(f func(ctx context.Context, userID int64) (ep1 *emptypb.Empty, err error)) *UserRepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the UserRepository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserRepositoryMockDeleteUser) When(ctx context.Context, userID int64) *UserRepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &UserRepositoryMockDeleteUserParams{ctx, userID},
		expectationOrigins: UserRepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteUserExpectation) Then(ep1 *emptypb.Empty, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteUserResults{ep1, err}
	return e.mock
}

// Times sets number of times UserRepository.DeleteUser should be invoked
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Times(n uint64) *mUserRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserRepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mUserRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_repository.UserRepository
func (mmDeleteUser *UserRepositoryMock) DeleteUser(ctx context.Context, userID int64) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, userID)
	}

	mm_params := UserRepositoryMockDeleteUserParams{ctx, userID}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockDeleteUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserRepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteUser.t.Errorf("UserRepositoryMock.DeleteUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserRepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserRepositoryMock.DeleteUser")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, userID)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserRepositoryMock.DeleteUser. %v %v", ctx, userID)
	return
}

// DeleteUserAfterCounter returns a count of finished UserRepositoryMock.DeleteUser invocations
func (mmDeleteUser *UserRepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserRepositoryMock.DeleteUser invocations
func (mmDeleteUser *UserRepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserRepositoryMockDeleteUser) Calls() []*UserRepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mUserRepositoryMockGetUserByID struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetUserByIDExpectation
	expectations       []*UserRepositoryMockGetUserByIDExpectation

	callArgs []*UserRepositoryMockGetUserByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetUserByIDExpectation specifies expectation struct of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetUserByIDParams
	paramPtrs          *UserRepositoryMockGetUserByIDParamPtrs
	expectationOrigins UserRepositoryMockGetUserByIDExpectationOrigins
	results            *UserRepositoryMockGetUserByIDResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetUserByIDParams contains parameters of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDParams struct {
	ctx    context.Context
	userID int64
}

// UserRepositoryMockGetUserByIDParamPtrs contains pointers to parameters of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserRepositoryMockGetUserByIDResults contains results of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDResults struct {
	up1 *model.User
	err error
}

// UserRepositoryMockGetUserByIDOrigins contains origins of expectations of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Optional() *mUserRepositoryMockGetUserByID {
	mmGetUserByID.optional = true
	return mmGetUserByID
}

// Expect sets up expected params for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Expect(ctx context.Context, userID int64) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.paramPtrs != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by ExpectParams functions")
	}

	mmGetUserByID.defaultExpectation.params = &UserRepositoryMockGetUserByIDParams{ctx, userID}
	mmGetUserByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByID
}

// ExpectUserIDParam2 sets up expected param userID for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) ExpectUserIDParam2(userID int64) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserByID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Inspect(f func(ctx context.Context, userID int64)) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Return(up1 *model.User, err error) *UserRepositoryMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &UserRepositoryMockGetUserByIDResults{up1, err}
	mmGetUserByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// Set uses given function f to mock the UserRepository.GetUserByID method
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Set(f func(ctx context.Context, userID int64) (up1 *model.User, err error)) *UserRepositoryMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	mmGetUserByID.mock.funcGetUserByIDOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// When sets expectation for the UserRepository.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mUserRepositoryMockGetUserByID) When(ctx context.Context, userID int64) *UserRepositoryMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetUserByIDExpectation{
		mock:               mmGetUserByID.mock,
		params:             &UserRepositoryMockGetUserByIDParams{ctx, userID},
		expectationOrigins: UserRepositoryMockGetUserByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetUserByID return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetUserByIDExpectation) Then(up1 *model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetUserByIDResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetUserByID should be invoked
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Times(n uint64) *mUserRepositoryMockGetUserByID {
	if n == 0 {
		mmGetUserByID.mock.t.Fatalf("Times of UserRepositoryMock.GetUserByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByID.expectedInvocations, n)
	mmGetUserByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByID
}

func (mmGetUserByID *mUserRepositoryMockGetUserByID) invocationsDone() bool {
	if len(mmGetUserByID.expectations) == 0 && mmGetUserByID.defaultExpectation == nil && mmGetUserByID.mock.funcGetUserByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByID.mock.afterGetUserByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByID implements mm_repository.UserRepository
func (mmGetUserByID *UserRepositoryMock) GetUserByID(ctx context.Context, userID int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	mmGetUserByID.t.Helper()

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(ctx, userID)
	}

	mm_params := UserRepositoryMockGetUserByIDParams{ctx, userID}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, &mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByID.GetUserByIDMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetUserByIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the UserRepositoryMock.GetUserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(ctx, userID)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to UserRepositoryMock.GetUserByID. %v %v", ctx, userID)
	return
}

// GetUserByIDAfterCounter returns a count of finished UserRepositoryMock.GetUserByID invocations
func (mmGetUserByID *UserRepositoryMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of UserRepositoryMock.GetUserByID invocations
func (mmGetUserByID *UserRepositoryMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Calls() []*UserRepositoryMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetUserByIDDone() bool {
	if m.GetUserByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByIDMock.invocationsDone()
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByIDCounter := mm_atomic.LoadUint64(&m.afterGetUserByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && afterGetUserByIDCounter < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s", m.GetUserByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s with params: %#v", m.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && afterGetUserByIDCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s", m.funcGetUserByIDOrigin)
	}

	if !m.GetUserByIDMock.invocationsDone() && afterGetUserByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetUserByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByIDMock.expectedInvocations), m.GetUserByIDMock.expectedInvocationsOrigin, afterGetUserByIDCounter)
	}
}

type mUserRepositoryMockGetUserByName struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetUserByNameExpectation
	expectations       []*UserRepositoryMockGetUserByNameExpectation

	callArgs []*UserRepositoryMockGetUserByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetUserByNameExpectation specifies expectation struct of the UserRepository.GetUserByName
type UserRepositoryMockGetUserByNameExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetUserByNameParams
	paramPtrs          *UserRepositoryMockGetUserByNameParamPtrs
	expectationOrigins UserRepositoryMockGetUserByNameExpectationOrigins
	results            *UserRepositoryMockGetUserByNameResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetUserByNameParams contains parameters of the UserRepository.GetUserByName
type UserRepositoryMockGetUserByNameParams struct {
	ctx  context.Context
	name string
}

// UserRepositoryMockGetUserByNameParamPtrs contains pointers to parameters of the UserRepository.GetUserByName
type UserRepositoryMockGetUserByNameParamPtrs struct {
	ctx  *context.Context
	name *string
}

// UserRepositoryMockGetUserByNameResults contains results of the UserRepository.GetUserByName
type UserRepositoryMockGetUserByNameResults struct {
	up1 *model.UserInfo
	err error
}

// UserRepositoryMockGetUserByNameOrigins contains origins of expectations of the UserRepository.GetUserByName
type UserRepositoryMockGetUserByNameExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Optional() *mUserRepositoryMockGetUserByName {
	mmGetUserByName.optional = true
	return mmGetUserByName
}

// Expect sets up expected params for UserRepository.GetUserByName
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Expect(ctx context.Context, name string) *mUserRepositoryMockGetUserByName {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserRepositoryMockGetUserByNameExpectation{}
	}

	if mmGetUserByName.defaultExpectation.paramPtrs != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by ExpectParams functions")
	}

	mmGetUserByName.defaultExpectation.params = &UserRepositoryMockGetUserByNameParams{ctx, name}
	mmGetUserByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByName.expectations {
		if minimock.Equal(e.params, mmGetUserByName.defaultExpectation.params) {
			mmGetUserByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByName.defaultExpectation.params)
		}
	}

	return mmGetUserByName
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetUserByName
func (mmGetUserByName *mUserRepositoryMockGetUserByName) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetUserByName {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserRepositoryMockGetUserByNameExpectation{}
	}

	if mmGetUserByName.defaultExpectation.params != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Expect")
	}

	if mmGetUserByName.defaultExpectation.paramPtrs == nil {
		mmGetUserByName.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByNameParamPtrs{}
	}
	mmGetUserByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByName
}

// ExpectNameParam2 sets up expected param name for UserRepository.GetUserByName
func (mmGetUserByName *mUserRepositoryMockGetUserByName) ExpectNameParam2(name string) *mUserRepositoryMockGetUserByName {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserRepositoryMockGetUserByNameExpectation{}
	}

	if mmGetUserByName.defaultExpectation.params != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Expect")
	}

	if mmGetUserByName.defaultExpectation.paramPtrs == nil {
		mmGetUserByName.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByNameParamPtrs{}
	}
	mmGetUserByName.defaultExpectation.paramPtrs.name = &name
	mmGetUserByName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetUserByName
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetUserByName
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Inspect(f func(ctx context.Context, name string)) *mUserRepositoryMockGetUserByName {
	if mmGetUserByName.mock.inspectFuncGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetUserByName")
	}

	mmGetUserByName.mock.inspectFuncGetUserByName = f

	return mmGetUserByName
}

// Return sets up results that will be returned by UserRepository.GetUserByName
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Return(up1 *model.UserInfo, err error) *UserRepositoryMock {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Set")
	}

	if mmGetUserByName.defaultExpectation == nil {
		mmGetUserByName.defaultExpectation = &UserRepositoryMockGetUserByNameExpectation{mock: mmGetUserByName.mock}
	}
	mmGetUserByName.defaultExpectation.results = &UserRepositoryMockGetUserByNameResults{up1, err}
	mmGetUserByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByName.mock
}

// Set uses given function f to mock the UserRepository.GetUserByName method
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Set(f func(ctx context.Context, name string) (up1 *model.UserInfo, err error)) *UserRepositoryMock {
	if mmGetUserByName.defaultExpectation != nil {
		mmGetUserByName.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetUserByName method")
	}

	if len(mmGetUserByName.expectations) > 0 {
		mmGetUserByName.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetUserByName method")
	}

	mmGetUserByName.mock.funcGetUserByName = f
	mmGetUserByName.mock.funcGetUserByNameOrigin = minimock.CallerInfo(1)
	return mmGetUserByName.mock
}

// When sets expectation for the UserRepository.GetUserByName which will trigger the result defined by the following
// Then helper
func (mmGetUserByName *mUserRepositoryMockGetUserByName) When(ctx context.Context, name string) *UserRepositoryMockGetUserByNameExpectation {
	if mmGetUserByName.mock.funcGetUserByName != nil {
		mmGetUserByName.mock.t.Fatalf("UserRepositoryMock.GetUserByName mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetUserByNameExpectation{
		mock:               mmGetUserByName.mock,
		params:             &UserRepositoryMockGetUserByNameParams{ctx, name},
		expectationOrigins: UserRepositoryMockGetUserByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByName.expectations = append(mmGetUserByName.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetUserByName return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetUserByNameExpectation) Then(up1 *model.UserInfo, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetUserByNameResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetUserByName should be invoked
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Times(n uint64) *mUserRepositoryMockGetUserByName {
	if n == 0 {
		mmGetUserByName.mock.t.Fatalf("Times of UserRepositoryMock.GetUserByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByName.expectedInvocations, n)
	mmGetUserByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByName
}

func (mmGetUserByName *mUserRepositoryMockGetUserByName) invocationsDone() bool {
	if len(mmGetUserByName.expectations) == 0 && mmGetUserByName.defaultExpectation == nil && mmGetUserByName.mock.funcGetUserByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByName.mock.afterGetUserByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByName implements mm_repository.UserRepository
func (mmGetUserByName *UserRepositoryMock) GetUserByName(ctx context.Context, name string) (up1 *model.UserInfo, err error) {
	mm_atomic.AddUint64(&mmGetUserByName.beforeGetUserByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByName.afterGetUserByNameCounter, 1)

	mmGetUserByName.t.Helper()

	if mmGetUserByName.inspectFuncGetUserByName != nil {
		mmGetUserByName.inspectFuncGetUserByName(ctx, name)
	}

	mm_params := UserRepositoryMockGetUserByNameParams{ctx, name}

	// Record call args
	mmGetUserByName.GetUserByNameMock.mutex.Lock()
	mmGetUserByName.GetUserByNameMock.callArgs = append(mmGetUserByName.GetUserByNameMock.callArgs, &mm_params)
	mmGetUserByName.GetUserByNameMock.mutex.Unlock()

	for _, e := range mmGetUserByName.GetUserByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByName.GetUserByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByName.GetUserByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByName.GetUserByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByName.GetUserByNameMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetUserByNameParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByName.t.Errorf("UserRepositoryMock.GetUserByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByName.GetUserByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetUserByName.t.Errorf("UserRepositoryMock.GetUserByName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByName.GetUserByNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByName.t.Errorf("UserRepositoryMock.GetUserByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByName.GetUserByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByName.GetUserByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByName.t.Fatal("No results are set for the UserRepositoryMock.GetUserByName")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByName.funcGetUserByName != nil {
		return mmGetUserByName.funcGetUserByName(ctx, name)
	}
	mmGetUserByName.t.Fatalf("Unexpected call to UserRepositoryMock.GetUserByName. %v %v", ctx, name)
	return
}

// GetUserByNameAfterCounter returns a count of finished UserRepositoryMock.GetUserByName invocations
func (mmGetUserByName *UserRepositoryMock) GetUserByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByName.afterGetUserByNameCounter)
}

// GetUserByNameBeforeCounter returns a count of UserRepositoryMock.GetUserByName invocations
func (mmGetUserByName *UserRepositoryMock) GetUserByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByName.beforeGetUserByNameCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetUserByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByName *mUserRepositoryMockGetUserByName) Calls() []*UserRepositoryMockGetUserByNameParams {
	mmGetUserByName.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetUserByNameParams, len(mmGetUserByName.callArgs))
	copy(argCopy, mmGetUserByName.callArgs)

	mmGetUserByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByNameDone returns true if the count of the GetUserByName invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetUserByNameDone() bool {
	if m.GetUserByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByNameMock.invocationsDone()
}

// MinimockGetUserByNameInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetUserByNameInspect() {
	for _, e := range m.GetUserByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByNameCounter := mm_atomic.LoadUint64(&m.afterGetUserByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByNameMock.defaultExpectation != nil && afterGetUserByNameCounter < 1 {
		if m.GetUserByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByName at\n%s", m.GetUserByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByName at\n%s with params: %#v", m.GetUserByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByName != nil && afterGetUserByNameCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.GetUserByName at\n%s", m.funcGetUserByNameOrigin)
	}

	if !m.GetUserByNameMock.invocationsDone() && afterGetUserByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetUserByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByNameMock.expectedInvocations), m.GetUserByNameMock.expectedInvocationsOrigin, afterGetUserByNameCounter)
	}
}

type mUserRepositoryMockIsNameExist struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockIsNameExistExpectation
	expectations       []*UserRepositoryMockIsNameExistExpectation

	callArgs []*UserRepositoryMockIsNameExistParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockIsNameExistExpectation specifies expectation struct of the UserRepository.IsNameExist
type UserRepositoryMockIsNameExistExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockIsNameExistParams
	paramPtrs          *UserRepositoryMockIsNameExistParamPtrs
	expectationOrigins UserRepositoryMockIsNameExistExpectationOrigins
	results            *UserRepositoryMockIsNameExistResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockIsNameExistParams contains parameters of the UserRepository.IsNameExist
type UserRepositoryMockIsNameExistParams struct {
	ctx  context.Context
	name string
}

// UserRepositoryMockIsNameExistParamPtrs contains pointers to parameters of the UserRepository.IsNameExist
type UserRepositoryMockIsNameExistParamPtrs struct {
	ctx  *context.Context
	name *string
}

// UserRepositoryMockIsNameExistResults contains results of the UserRepository.IsNameExist
type UserRepositoryMockIsNameExistResults struct {
	b1  bool
	err error
}

// UserRepositoryMockIsNameExistOrigins contains origins of expectations of the UserRepository.IsNameExist
type UserRepositoryMockIsNameExistExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Optional() *mUserRepositoryMockIsNameExist {
	mmIsNameExist.optional = true
	return mmIsNameExist
}

// Expect sets up expected params for UserRepository.IsNameExist
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Expect(ctx context.Context, name string) *mUserRepositoryMockIsNameExist {
	if mmIsNameExist.mock.funcIsNameExist != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Set")
	}

	if mmIsNameExist.defaultExpectation == nil {
		mmIsNameExist.defaultExpectation = &UserRepositoryMockIsNameExistExpectation{}
	}

	if mmIsNameExist.defaultExpectation.paramPtrs != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by ExpectParams functions")
	}

	mmIsNameExist.defaultExpectation.params = &UserRepositoryMockIsNameExistParams{ctx, name}
	mmIsNameExist.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsNameExist.expectations {
		if minimock.Equal(e.params, mmIsNameExist.defaultExpectation.params) {
			mmIsNameExist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsNameExist.defaultExpectation.params)
		}
	}

	return mmIsNameExist
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.IsNameExist
func (mmIsNameExist *mUserRepositoryMockIsNameExist) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockIsNameExist {
	if mmIsNameExist.mock.funcIsNameExist != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Set")
	}

	if mmIsNameExist.defaultExpectation == nil {
		mmIsNameExist.defaultExpectation = &UserRepositoryMockIsNameExistExpectation{}
	}

	if mmIsNameExist.defaultExpectation.params != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Expect")
	}

	if mmIsNameExist.defaultExpectation.paramPtrs == nil {
		mmIsNameExist.defaultExpectation.paramPtrs = &UserRepositoryMockIsNameExistParamPtrs{}
	}
	mmIsNameExist.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsNameExist.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsNameExist
}

// ExpectNameParam2 sets up expected param name for UserRepository.IsNameExist
func (mmIsNameExist *mUserRepositoryMockIsNameExist) ExpectNameParam2(name string) *mUserRepositoryMockIsNameExist {
	if mmIsNameExist.mock.funcIsNameExist != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Set")
	}

	if mmIsNameExist.defaultExpectation == nil {
		mmIsNameExist.defaultExpectation = &UserRepositoryMockIsNameExistExpectation{}
	}

	if mmIsNameExist.defaultExpectation.params != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Expect")
	}

	if mmIsNameExist.defaultExpectation.paramPtrs == nil {
		mmIsNameExist.defaultExpectation.paramPtrs = &UserRepositoryMockIsNameExistParamPtrs{}
	}
	mmIsNameExist.defaultExpectation.paramPtrs.name = &name
	mmIsNameExist.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmIsNameExist
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.IsNameExist
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Inspect(f func(ctx context.Context, name string)) *mUserRepositoryMockIsNameExist {
	if mmIsNameExist.mock.inspectFuncIsNameExist != nil {
		mmIsNameExist.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.IsNameExist")
	}

	mmIsNameExist.mock.inspectFuncIsNameExist = f

	return mmIsNameExist
}

// Return sets up results that will be returned by UserRepository.IsNameExist
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Return(b1 bool, err error) *UserRepositoryMock {
	if mmIsNameExist.mock.funcIsNameExist != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Set")
	}

	if mmIsNameExist.defaultExpectation == nil {
		mmIsNameExist.defaultExpectation = &UserRepositoryMockIsNameExistExpectation{mock: mmIsNameExist.mock}
	}
	mmIsNameExist.defaultExpectation.results = &UserRepositoryMockIsNameExistResults{b1, err}
	mmIsNameExist.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsNameExist.mock
}

// Set uses given function f to mock the UserRepository.IsNameExist method
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Set(f func(ctx context.Context, name string) (b1 bool, err error)) *UserRepositoryMock {
	if mmIsNameExist.defaultExpectation != nil {
		mmIsNameExist.mock.t.Fatalf("Default expectation is already set for the UserRepository.IsNameExist method")
	}

	if len(mmIsNameExist.expectations) > 0 {
		mmIsNameExist.mock.t.Fatalf("Some expectations are already set for the UserRepository.IsNameExist method")
	}

	mmIsNameExist.mock.funcIsNameExist = f
	mmIsNameExist.mock.funcIsNameExistOrigin = minimock.CallerInfo(1)
	return mmIsNameExist.mock
}

// When sets expectation for the UserRepository.IsNameExist which will trigger the result defined by the following
// Then helper
func (mmIsNameExist *mUserRepositoryMockIsNameExist) When(ctx context.Context, name string) *UserRepositoryMockIsNameExistExpectation {
	if mmIsNameExist.mock.funcIsNameExist != nil {
		mmIsNameExist.mock.t.Fatalf("UserRepositoryMock.IsNameExist mock is already set by Set")
	}

	expectation := &UserRepositoryMockIsNameExistExpectation{
		mock:               mmIsNameExist.mock,
		params:             &UserRepositoryMockIsNameExistParams{ctx, name},
		expectationOrigins: UserRepositoryMockIsNameExistExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsNameExist.expectations = append(mmIsNameExist.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.IsNameExist return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockIsNameExistExpectation) Then(b1 bool, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockIsNameExistResults{b1, err}
	return e.mock
}

// Times sets number of times UserRepository.IsNameExist should be invoked
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Times(n uint64) *mUserRepositoryMockIsNameExist {
	if n == 0 {
		mmIsNameExist.mock.t.Fatalf("Times of UserRepositoryMock.IsNameExist mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsNameExist.expectedInvocations, n)
	mmIsNameExist.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsNameExist
}

func (mmIsNameExist *mUserRepositoryMockIsNameExist) invocationsDone() bool {
	if len(mmIsNameExist.expectations) == 0 && mmIsNameExist.defaultExpectation == nil && mmIsNameExist.mock.funcIsNameExist == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsNameExist.mock.afterIsNameExistCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsNameExist.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsNameExist implements mm_repository.UserRepository
func (mmIsNameExist *UserRepositoryMock) IsNameExist(ctx context.Context, name string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsNameExist.beforeIsNameExistCounter, 1)
	defer mm_atomic.AddUint64(&mmIsNameExist.afterIsNameExistCounter, 1)

	mmIsNameExist.t.Helper()

	if mmIsNameExist.inspectFuncIsNameExist != nil {
		mmIsNameExist.inspectFuncIsNameExist(ctx, name)
	}

	mm_params := UserRepositoryMockIsNameExistParams{ctx, name}

	// Record call args
	mmIsNameExist.IsNameExistMock.mutex.Lock()
	mmIsNameExist.IsNameExistMock.callArgs = append(mmIsNameExist.IsNameExistMock.callArgs, &mm_params)
	mmIsNameExist.IsNameExistMock.mutex.Unlock()

	for _, e := range mmIsNameExist.IsNameExistMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsNameExist.IsNameExistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsNameExist.IsNameExistMock.defaultExpectation.Counter, 1)
		mm_want := mmIsNameExist.IsNameExistMock.defaultExpectation.params
		mm_want_ptrs := mmIsNameExist.IsNameExistMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockIsNameExistParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsNameExist.t.Errorf("UserRepositoryMock.IsNameExist got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsNameExist.IsNameExistMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmIsNameExist.t.Errorf("UserRepositoryMock.IsNameExist got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsNameExist.IsNameExistMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsNameExist.t.Errorf("UserRepositoryMock.IsNameExist got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsNameExist.IsNameExistMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsNameExist.IsNameExistMock.defaultExpectation.results
		if mm_results == nil {
			mmIsNameExist.t.Fatal("No results are set for the UserRepositoryMock.IsNameExist")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsNameExist.funcIsNameExist != nil {
		return mmIsNameExist.funcIsNameExist(ctx, name)
	}
	mmIsNameExist.t.Fatalf("Unexpected call to UserRepositoryMock.IsNameExist. %v %v", ctx, name)
	return
}

// IsNameExistAfterCounter returns a count of finished UserRepositoryMock.IsNameExist invocations
func (mmIsNameExist *UserRepositoryMock) IsNameExistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsNameExist.afterIsNameExistCounter)
}

// IsNameExistBeforeCounter returns a count of UserRepositoryMock.IsNameExist invocations
func (mmIsNameExist *UserRepositoryMock) IsNameExistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsNameExist.beforeIsNameExistCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.IsNameExist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsNameExist *mUserRepositoryMockIsNameExist) Calls() []*UserRepositoryMockIsNameExistParams {
	mmIsNameExist.mutex.RLock()

	argCopy := make([]*UserRepositoryMockIsNameExistParams, len(mmIsNameExist.callArgs))
	copy(argCopy, mmIsNameExist.callArgs)

	mmIsNameExist.mutex.RUnlock()

	return argCopy
}

// MinimockIsNameExistDone returns true if the count of the IsNameExist invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockIsNameExistDone() bool {
	if m.IsNameExistMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsNameExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsNameExistMock.invocationsDone()
}

// MinimockIsNameExistInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockIsNameExistInspect() {
	for _, e := range m.IsNameExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.IsNameExist at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsNameExistCounter := mm_atomic.LoadUint64(&m.afterIsNameExistCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsNameExistMock.defaultExpectation != nil && afterIsNameExistCounter < 1 {
		if m.IsNameExistMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.IsNameExist at\n%s", m.IsNameExistMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.IsNameExist at\n%s with params: %#v", m.IsNameExistMock.defaultExpectation.expectationOrigins.origin, *m.IsNameExistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsNameExist != nil && afterIsNameExistCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.IsNameExist at\n%s", m.funcIsNameExistOrigin)
	}

	if !m.IsNameExistMock.invocationsDone() && afterIsNameExistCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.IsNameExist at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsNameExistMock.expectedInvocations), m.IsNameExistMock.expectedInvocationsOrigin, afterIsNameExistCounter)
	}
}

type mUserRepositoryMockUpdateUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateUserExpectation
	expectations       []*UserRepositoryMockUpdateUserExpectation

	callArgs []*UserRepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockUpdateUserExpectation specifies expectation struct of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockUpdateUserParams
	paramPtrs          *UserRepositoryMockUpdateUserParamPtrs
	expectationOrigins UserRepositoryMockUpdateUserExpectationOrigins
	results            *UserRepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockUpdateUserParams contains parameters of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserParams struct {
	ctx  context.Context
	user *model.UserUpdate
}

// UserRepositoryMockUpdateUserParamPtrs contains pointers to parameters of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	user **model.UserUpdate
}

// UserRepositoryMockUpdateUserResults contains results of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserResults struct {
	ep1 *emptypb.Empty
	err error
}

// UserRepositoryMockUpdateUserOrigins contains origins of expectations of the UserRepository.UpdateUser
type UserRepositoryMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Optional() *mUserRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Expect(ctx context.Context, user *model.UserUpdate) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserRepositoryMockUpdateUserParams{ctx, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam2 sets up expected param user for UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) ExpectUserParam2(user *model.UserUpdate) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, user *model.UserUpdate)) *mUserRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UserRepository.UpdateUser
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Return(ep1 *emptypb.Empty, err error) *UserRepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserRepositoryMockUpdateUserResults{ep1, err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UserRepository.UpdateUser method
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Set(f func(ctx context.Context, user *model.UserUpdate) (ep1 *emptypb.Empty, err error)) *UserRepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the UserRepository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserRepositoryMockUpdateUser) When(ctx context.Context, user *model.UserUpdate) *UserRepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UserRepositoryMockUpdateUserParams{ctx, user},
		expectationOrigins: UserRepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateUserExpectation) Then(ep1 *emptypb.Empty, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateUserResults{ep1, err}
	return e.mock
}

// Times sets number of times UserRepository.UpdateUser should be invoked
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Times(n uint64) *mUserRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserRepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUserRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_repository.UserRepository
func (mmUpdateUser *UserRepositoryMock) UpdateUser(ctx context.Context, user *model.UserUpdate) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, user)
	}

	mm_params := UserRepositoryMockUpdateUserParams{ctx, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUpdateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserRepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("UserRepositoryMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserRepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserRepositoryMock.UpdateUser")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserRepositoryMock.UpdateUser. %v %v", ctx, user)
	return
}

// UpdateUserAfterCounter returns a count of finished UserRepositoryMock.UpdateUser invocations
func (mmUpdateUser *UserRepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserRepositoryMock.UpdateUser invocations
func (mmUpdateUser *UserRepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserRepositoryMockUpdateUser) Calls() []*UserRepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserByIDInspect()

			m.MinimockGetUserByNameInspect()

			m.MinimockIsNameExistInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockGetUserByNameDone() &&
		m.MinimockIsNameExistDone() &&
		m.MinimockUpdateUserDone()
}
